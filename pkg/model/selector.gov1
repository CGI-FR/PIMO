// Copyright (C) 2021 CGI France
//
// This file is part of PIMO.
//
// PIMO is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// PIMO is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with PIMO.  If not, see <http://www.gnu.org/licenses/>.

package model

import (
	"log"
	"reflect"

	"github.com/cgi-fr/pimo/pkg/selector"
)

// This file contains the old implementation of selectors.

// Dictionary is a Map with string as key and Entry as value
type Dictionary = map[string]interface{}

// Entry is a dictionary value
type Entry = interface{}

func NewPathSelector(path string) Selector {
	mainEntry := strings.SplitN(path, ".", 2)
	if len(mainEntry) == 2 {
		return ComplexePathSelector{mainEntry[0], NewPathSelector(mainEntry[1])}
	} else {
		return NewSimplePathSelector(mainEntry[0])
	}
}

func NewPathSelector(path string) selector.Selector {
	return selector.NewSelector(path)
}

// Selector acces to a specific data into a dictonary
type Selector interface {
	Read(Dictionary) (Entry, bool)
	Write(Dictionary, Entry) Dictionary
	Delete(Dictionary) Dictionary
	ReadContext(Dictionary) (Dictionary, string, bool)
	WriteContext(Dictionary, Entry) Dictionary
}

type ComplexePathSelector struct {
	path        string
	subSelector Selector
}

func (s ComplexePathSelector) ApplyContext(Dictionary, Dictionary, ...selector.Applier) bool {
	log.Fatal("Not implemented")
	return false
}

func (s ComplexePathSelector) Apply(Dictionary, ...selector.Applier) bool {
	log.Fatal("Not implemented")
	return false
}

func (s ComplexePathSelector) Read(dictionary Dictionary) (entry Entry, ok bool) {
	entry, ok = dictionary[s.path]
	if !ok {
		return
	}

	switch typedMatch := entry.(type) {
	case []Entry:
		entry = []Entry{}
		for _, subEntry := range typedMatch {
			var subResult Entry
			subResult, ok = s.subSelector.Read(subEntry.(Dictionary))
			if !ok {
				return
			}

			entry = append(entry.([]Entry), subResult.(Entry))
		}
		return
	case Dictionary:
		return s.subSelector.Read(typedMatch)
	default:
		return nil, false
	}
}

func (s ComplexePathSelector) ReadContext(dictionary Dictionary) (Dictionary, string, bool) {
	entry, ok := dictionary[s.path]
	if !ok {
		return dictionary, "", false
	}
	subEntry, ok := entry.(Dictionary)
	if !ok {
		return dictionary, "", false
	}
	return s.subSelector.ReadContext(subEntry)
}

func (s ComplexePathSelector) Write(dictionary Dictionary, entry Entry) Dictionary {
	result := Dictionary{}

	for k, v := range dictionary {
		result[k] = v
	}

	v := reflect.ValueOf(entry)
	switch v.Kind() {
	case reflect.Slice:
		subTargetArray, isArray := result[s.path].([]Entry)
		if !isArray {
			result[s.path] = s.subSelector.Write(result[s.path].(Dictionary), entry)
		} else {
			subArray := []Entry{}
			for i := 0; i < v.Len(); i++ {
				subArray = append(subArray, s.subSelector.Write(subTargetArray[i].(Dictionary), v.Index(i).Interface()))
			}
			result[s.path] = subArray
		}

	default:
		result[s.path] = s.subSelector.Write(result[s.path].(Dictionary), entry)
	}

	return result
}

func (s ComplexePathSelector) WriteContext(dictionary Dictionary, entry Entry) Dictionary {
	return dictionary
}

func (s ComplexePathSelector) Delete(dictionary Dictionary) Dictionary {
	result := Dictionary{}

	for k, v := range dictionary {
		if k == s.path {
			result[k] = s.subSelector.Delete(v.(Dictionary))
		}
	}
	return result
}

func NewSimplePathSelector(path string) Selector {
	return SimplePathSelector{path}
}

type SimplePathSelector struct {
	Path string
}

func (s SimplePathSelector) ApplyContext(Dictionary, ...selector.Applier) bool {
	log.Fatal("Not implemented")
	return false
}

func (s SimplePathSelector) Apply(Dictionary, ...selector.Applier) bool {
	log.Fatal("Not implemented")
	return false
}

func (s SimplePathSelector) Read(dictionary Dictionary) (entry Entry, ok bool) {
	entry, ok = dictionary[s.Path]
	return
}

func (s SimplePathSelector) ReadContext(dictionary Dictionary) (Dictionary, string, bool) {
	return dictionary, s.Path, true
}

func (s SimplePathSelector) Write(dictionary Dictionary, entry Entry) Dictionary {
	result := Dictionary{}
	for k, v := range dictionary {
		result[k] = v
	}
	result[s.Path] = entry
	return result
}

func (s SimplePathSelector) WriteContext(dictionary Dictionary, entry Entry) Dictionary {
	return dictionary
}

func (s SimplePathSelector) Delete(dictionary Dictionary) Dictionary {
	result := Dictionary{}

	for k, v := range dictionary {
		if k != s.Path {
			result[k] = v
		}
	}
	return result
}
